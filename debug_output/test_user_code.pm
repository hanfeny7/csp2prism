// ===================================================
// Enhanced PRISM MDP Model (Generated by pat2prism)
// Optimized for Security Protocol Verification
// ===================================================

mdp

// ===== Configuration Parameters =====
const double p_flip = 0.02;  // Channel error probability
const int MAX_NONCE = 10000;

// ===== Message Type Encoding =====
// Maps message names to integer indices for channel variables
const int MSG_NO_MSG = 0;  // NO_MSG
const int MSG_LO_CoAP_POST = 1;  // LO_CoAP_POST
const int MSG_EAP_Request_PSK_M1 = 2;  // EAP_Request_PSK_M1
const int MSG_EAP_Response_PSK_M2 = 3;  // EAP_Response_PSK_M2
const int MSG_EAP_Request_PSK_M3 = 4;  // EAP_Request_PSK_M3
const int MSG_EAP_Response_PSK_M4 = 5;  // EAP_Response_PSK_M4
const int MSG_EAP_Success = 6;  // EAP_Success
const int MSG_Final_CoAP_POST = 7;  // Final_CoAP_POST
const int MSG_CoAP_ACK = 8;  // CoAP_ACK

// ===== Global Variables =====
// Protocol variables (from PAT declarations)
global EAP_TYPES : [0..7] init 0  // EAP_Request_PSK_M1, EAP_Response_PSK_M2, EAP_Request_PSK_M3...;
global PSK : [0..10000] init 1234;
global ID_P : [0..10000] init 1;
global ID_S : [0..10000] init 2;
global auth_complete_SO : bool init false;
global auth_complete_Controller : bool init false;
global auth_complete_AAA : bool init false;
global MAC_P_valid : bool init false;
global MAC_S_valid : bool init false;
global AUTH_valid : bool init false;
global random_var : [0..10000] init 101;
global N_C : [0..10000] init 0;
global N_P : [0..10000] init 0;
global N_S : [0..10000] init 0;
global AK : [0..10000] init 0;
global MSK : [0..10000] init 0;
global EMSK : [0..10000] init 0;
global MAC_P : [0..10000] init 0;
global MAC_S : [0..10000] init 0;
global PCHANNEL : [0..10000] init 0;
global AUTH : [0..10000] init 0;
global expected_AUTH : [0..10000] init 0;
global LO_CoAP_POST_ID_P : [0..100] init 0  // ID field;
global LO_CoAP_POST_N_P : [0..10000] init 0  // nonce field;
global EAP_Request_PSK_M1_N_S : [0..10000] init 0  // nonce field;
global EAP_Request_PSK_M1_ID_S : [0..100] init 0  // ID field;
global EAP_Response_PSK_M2_MAC_P : [0..1000] init 0  // MAC field;
global EAP_Request_PSK_M3_MAC_S : [0..1000] init 0  // MAC field;
global EAP_Request_PSK_M3_PCHANNEL : [0..1000] init 0  // message field;
global EAP_Success_MSK : [0..1000] init 0  // message field;
global Final_CoAP_POST_N_C : [0..10000] init 0  // nonce field;
global Final_CoAP_POST_AUTH : [0..1000] init 0  // message field;

// Channel variables (one per channel)
global chan_ComSC : [0..8] init 0;  // Channel ComSC
global chan_ComCA : [0..8] init 0;  // Channel ComCA

// ===== Process Modules =====
// Process: SmartObject
module SmartObject
  // State variable for SmartObject
  s_SmartObject : [0..10] init 0;

  // Transition 0: call_Generate_N_P
  // Function call: call_Generate_N_P (TODO: implement logic)
  [] s_SmartObject=0 ->
    (s_SmartObject' = 1);

  // Transition 1: sync_ComSC_LO_CoAP_POST
  // Synchronized action: sync_ComSC_LO_CoAP_POST
  [sync_ComSC_LO_CoAP_POST] s_SmartObject=1 ->
    (LO_CoAP_POST_ID_P' = ID_P) &
    (LO_CoAP_POST_N_P' = N_P) &
    (chan_ComSC' = MSG_LO_CoAP_POST) &
    (s_SmartObject' = 2);

  // Transition 2: sync_ComSC_EAP_Request_PSK_M1
  // Synchronized action: sync_ComSC_EAP_Request_PSK_M1
  [sync_ComSC_EAP_Request_PSK_M1] s_SmartObject=2 ->
    (N_S' = EAP_Request_PSK_M1_N_S) &
    (ID_S' = EAP_Request_PSK_M1_ID_S) &
    (chan_ComSC' = MSG_EAP_Request_PSK_M1) &
    (s_SmartObject' = 3);

  // Transition 3: call_Compute_AK
  // Function call: call_Compute_AK (TODO: implement logic)
  [] s_SmartObject=3 ->
    (s_SmartObject' = 4);

  // Transition 4: call_Compute_MAC_P
  // Function call: call_Compute_MAC_P (TODO: implement logic)
  [] s_SmartObject=4 ->
    (s_SmartObject' = 5);

  // Transition 5: sync_ComSC_EAP_Response_PSK_M2
  // Synchronized action: sync_ComSC_EAP_Response_PSK_M2
  [sync_ComSC_EAP_Response_PSK_M2] s_SmartObject=5 ->
    (EAP_Response_PSK_M2_MAC_P' = MAC_P) &
    (chan_ComSC' = MSG_EAP_Response_PSK_M2) &
    (s_SmartObject' = 6);

  // Transition 6: sync_ComSC_EAP_Request_PSK_M3
  // Synchronized action: sync_ComSC_EAP_Request_PSK_M3
  [sync_ComSC_EAP_Request_PSK_M3] s_SmartObject=6 ->
    (MAC_S' = EAP_Request_PSK_M3_MAC_S) &
    (PCHANNEL' = EAP_Request_PSK_M3_PCHANNEL) &
    (chan_ComSC' = MSG_EAP_Request_PSK_M3) &
    (s_SmartObject' = 7);

  // Transition 7: call_Verify_MAC_S
  // Function call: call_Verify_MAC_S (TODO: implement logic)
  [] s_SmartObject=7 ->
    (s_SmartObject' = 8);

  // Transition 8: call_if
  // Function call: call_if (TODO: implement logic)
  [] s_SmartObject=8 ->
    (s_SmartObject' = 9);

  // Terminal state (self-loop)
  [] s_SmartObject=10 -> (s_SmartObject' = 10);

endmodule
// Process: Controller
module Controller
  // State variable for Controller
  s_Controller : [0..18] init 0;

  // Transition 0: sync_ComSC_LO_CoAP_POST
  // Synchronized action: sync_ComSC_LO_CoAP_POST
  [sync_ComSC_LO_CoAP_POST] s_Controller=0 ->
    (ID_P' = LO_CoAP_POST_ID_P) &
    (N_P' = LO_CoAP_POST_N_P) &
    (chan_ComSC' = MSG_LO_CoAP_POST) &
    (s_Controller' = 1);

  // Transition 1: sync_ComCA_LO_CoAP_POST
  // Synchronized action: sync_ComCA_LO_CoAP_POST
  [sync_ComCA_LO_CoAP_POST] s_Controller=1 ->
    (LO_CoAP_POST_ID_P' = ID_P) &
    (LO_CoAP_POST_N_P' = N_P) &
    (chan_ComCA' = MSG_LO_CoAP_POST) &
    (s_Controller' = 2);

  // Transition 2: sync_ComCA_EAP_Request_PSK_M1
  // Synchronized action: sync_ComCA_EAP_Request_PSK_M1
  [sync_ComCA_EAP_Request_PSK_M1] s_Controller=2 ->
    (N_S' = EAP_Request_PSK_M1_N_S) &
    (ID_S' = EAP_Request_PSK_M1_ID_S) &
    (chan_ComCA' = MSG_EAP_Request_PSK_M1) &
    (s_Controller' = 3);

  // Transition 3: sync_ComSC_EAP_Request_PSK_M1
  // Synchronized action: sync_ComSC_EAP_Request_PSK_M1
  [sync_ComSC_EAP_Request_PSK_M1] s_Controller=3 ->
    (EAP_Request_PSK_M1_N_S' = N_S) &
    (EAP_Request_PSK_M1_ID_S' = ID_S) &
    (chan_ComSC' = MSG_EAP_Request_PSK_M1) &
    (s_Controller' = 4);

  // Transition 4: sync_ComSC_EAP_Response_PSK_M2
  // Synchronized action: sync_ComSC_EAP_Response_PSK_M2
  [sync_ComSC_EAP_Response_PSK_M2] s_Controller=4 ->
    (MAC_P' = EAP_Response_PSK_M2_MAC_P) &
    (chan_ComSC' = MSG_EAP_Response_PSK_M2) &
    (s_Controller' = 5);

  // Transition 5: sync_ComCA_EAP_Response_PSK_M2
  // Synchronized action: sync_ComCA_EAP_Response_PSK_M2
  [sync_ComCA_EAP_Response_PSK_M2] s_Controller=5 ->
    (EAP_Response_PSK_M2_MAC_P' = MAC_P) &
    (chan_ComCA' = MSG_EAP_Response_PSK_M2) &
    (s_Controller' = 6);

  // Transition 6: sync_ComCA_EAP_Request_PSK_M3
  // Synchronized action: sync_ComCA_EAP_Request_PSK_M3
  [sync_ComCA_EAP_Request_PSK_M3] s_Controller=6 ->
    (MAC_S' = EAP_Request_PSK_M3_MAC_S) &
    (PCHANNEL' = EAP_Request_PSK_M3_PCHANNEL) &
    (chan_ComCA' = MSG_EAP_Request_PSK_M3) &
    (s_Controller' = 7);

  // Transition 7: sync_ComSC_EAP_Request_PSK_M3
  // Synchronized action: sync_ComSC_EAP_Request_PSK_M3
  [sync_ComSC_EAP_Request_PSK_M3] s_Controller=7 ->
    (EAP_Request_PSK_M3_MAC_S' = MAC_S) &
    (EAP_Request_PSK_M3_PCHANNEL' = PCHANNEL) &
    (chan_ComSC' = MSG_EAP_Request_PSK_M3) &
    (s_Controller' = 8);

  // Transition 8: sync_ComSC_EAP_Response_PSK_M4
  // Synchronized action: sync_ComSC_EAP_Response_PSK_M4
  [sync_ComSC_EAP_Response_PSK_M4] s_Controller=8 ->
    (chan_ComSC' = MSG_EAP_Response_PSK_M4) &
    (s_Controller' = 9);

  // Transition 9: sync_ComCA_EAP_Response_PSK_M4
  // Synchronized action: sync_ComCA_EAP_Response_PSK_M4
  [sync_ComCA_EAP_Response_PSK_M4] s_Controller=9 ->
    (chan_ComCA' = MSG_EAP_Response_PSK_M4) &
    (s_Controller' = 10);

  // Transition 10: sync_ComCA_EAP_Success
  // Synchronized action: sync_ComCA_EAP_Success
  [sync_ComCA_EAP_Success] s_Controller=10 ->
    (MSK' = EAP_Success_MSK) &
    (chan_ComCA' = MSG_EAP_Success) &
    (s_Controller' = 11);

  // Transition 11: call_Generate_N_C
  // Function call: call_Generate_N_C (TODO: implement logic)
  [] s_Controller=11 ->
    (s_Controller' = 12);

  // Transition 12: call_Compute_AUTH
  // Function call: call_Compute_AUTH (TODO: implement logic)
  [] s_Controller=12 ->
    (s_Controller' = 13);

  // Transition 13: sync_ComSC_Final_CoAP_POST
  // Synchronized action: sync_ComSC_Final_CoAP_POST
  [sync_ComSC_Final_CoAP_POST] s_Controller=13 ->
    (Final_CoAP_POST_N_C' = N_C) &
    (Final_CoAP_POST_AUTH' = AUTH) &
    (chan_ComSC' = MSG_Final_CoAP_POST) &
    (s_Controller' = 14);

  // Transition 14: sync_ComSC_CoAP_ACK
  // Synchronized action: sync_ComSC_CoAP_ACK
  [sync_ComSC_CoAP_ACK] s_Controller=14 ->
    (chan_ComSC' = MSG_CoAP_ACK) &
    (s_Controller' = 15);

  // Transition 15: assign_auth_complete_Controller
  [] s_Controller=15 ->
    (auth_complete_Controller' = true) &
    (s_Controller' = 16);

  // Transition 16: call_Controller
  // Function call: call_Controller (TODO: implement logic)
  [] s_Controller=16 ->
    (s_Controller' = 17);

  // Terminal state (self-loop)
  [] s_Controller=18 -> (s_Controller' = 18);

endmodule
// Process: AAA_Server
module AAA_Server
  // State variable for AAA_Server
  s_AAA_Server : [0..9] init 0;

  // Transition 0: sync_ComCA_LO_CoAP_POST
  // Synchronized action: sync_ComCA_LO_CoAP_POST
  [sync_ComCA_LO_CoAP_POST] s_AAA_Server=0 ->
    (ID_P' = LO_CoAP_POST_ID_P) &
    (N_P' = LO_CoAP_POST_N_P) &
    (chan_ComCA' = MSG_LO_CoAP_POST) &
    (s_AAA_Server' = 1);

  // Transition 1: call_Generate_N_S
  // Function call: call_Generate_N_S (TODO: implement logic)
  [] s_AAA_Server=1 ->
    (s_AAA_Server' = 2);

  // Transition 2: sync_ComCA_EAP_Request_PSK_M1
  // Synchronized action: sync_ComCA_EAP_Request_PSK_M1
  [sync_ComCA_EAP_Request_PSK_M1] s_AAA_Server=2 ->
    (EAP_Request_PSK_M1_N_S' = N_S) &
    (EAP_Request_PSK_M1_ID_S' = ID_S) &
    (chan_ComCA' = MSG_EAP_Request_PSK_M1) &
    (s_AAA_Server' = 3);

  // Transition 3: sync_ComCA_EAP_Response_PSK_M2
  // Synchronized action: sync_ComCA_EAP_Response_PSK_M2
  [sync_ComCA_EAP_Response_PSK_M2] s_AAA_Server=3 ->
    (MAC_P' = EAP_Response_PSK_M2_MAC_P) &
    (chan_ComCA' = MSG_EAP_Response_PSK_M2) &
    (s_AAA_Server' = 4);

  // Transition 4: call_Compute_AK
  // Function call: call_Compute_AK (TODO: implement logic)
  [] s_AAA_Server=4 ->
    (s_AAA_Server' = 5);

  // Transition 5: call_Compute_MAC_P
  // Function call: call_Compute_MAC_P (TODO: implement logic)
  [] s_AAA_Server=5 ->
    (s_AAA_Server' = 6);

  // Transition 6: call_Verify_MAC_P
  // Function call: call_Verify_MAC_P (TODO: implement logic)
  [] s_AAA_Server=6 ->
    (s_AAA_Server' = 7);

  // Transition 7: call_if
  // Function call: call_if (TODO: implement logic)
  [] s_AAA_Server=7 ->
    (s_AAA_Server' = 8);

  // Terminal state (self-loop)
  [] s_AAA_Server=9 -> (s_AAA_Server' = 9);

endmodule
// ===== Intruder/Attacker Model (Optional) =====
// TODO: Add Dolev-Yao intruder model for security analysis
// module Intruder
//   // Attacker can intercept, forge, and replay messages
// endmodule

// ===== Labels for Properties =====
// Define observable states for verification
label "error" = false;  // TODO: Define error condition
label "auth_success" = s_SmartObject=9 & s_Controller=17 & s_AAA_Server=8;
label "deadlock" = s_SmartObject=10 | s_Controller=18 | s_AAA_Server=9;

// ===== Rewards (Optional) =====
// rewards "message_cost"
//   [sync_ComSC_*] true : 1;  // Cost per message
// endrewards

// ===== Notes for Manual Refinement =====
// 1. Function calls (call_*) are placeholders - implement crypto logic
// 2. Add probabilistic channel model (message loss, corruption)
// 3. Implement Dolev-Yao intruder if security analysis required
// 4. Define specific error conditions in "error" label
// 5. Add reward structures for performance metrics