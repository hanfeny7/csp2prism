// ===================================================
// Enhanced PRISM MDP Model (Generated by pat2prism)
// Optimized for Security Protocol Verification
// ===================================================

mdp

// ===== Configuration Parameters =====
const double p_flip = {{ opts.p_flip | default(0.02) }};  // Channel error probability
const int MAX_NONCE = {{ opts.nonce_size | default(10000) }};

// ===== Message Type Encoding =====
// Maps message names to integer indices for channel variables
{% for msg in msgs -%}
const int MSG_{{ msg }} = {{ loop.index0 }};  // {{ msg }}
{% endfor %}

// ===== Global Variables =====
{% if spec.variables -%}
// Protocol variables (from PAT declarations)
{% for var_name, var_type in spec.variables.items() -%}
global {{ var_name }} : {{ var_type }};
{% endfor %}
{% endif %}

{% if channels -%}
// Channel variables (one per channel)
{% for ch in channels -%}
global chan_{{ ch.name }} : [0..{{ msgs|length - 1 }}] init 0;  // Channel {{ ch.name }}
{% endfor %}
{% endif %}

// ===== Process Modules =====
{%- for proc in processes %}

// Process: {{ proc.name }}
module {{ proc.name }}
  // State variable for {{ proc.name }}
  s_{{ proc.name }} : [0..{{ proc.states|length }}] init 0;

  {% for trans in proc.transitions %}
  // Transition {{ loop.index0 }}: {{ trans.label }}
  {% if trans.label.startswith('sync_') %}
  // Synchronized action: {{ trans.label }}
  [{{ trans.label }}] s_{{ proc.name }}={{ trans.from_state }}{% if trans.guard %} & {{ trans.guard.condition }}{% endif %} ->
    {% if trans.updates %}
      {% for update in trans.updates %}
    ({{ update.variable }}' = {{ update.expression }}) &
      {% endfor %}
    {% endif %}
    {% if trans.channel and trans.message %}
    (chan_{{ trans.channel }}' = MSG_{{ trans.message }}) &
    {% endif %}
    (s_{{ proc.name }}' = {{ trans.to_state }});
  {% elif trans.label.startswith('assign_') %}
  [] s_{{ proc.name }}={{ trans.from_state }}{% if trans.guard %} & {{ trans.guard.condition }}{% endif %} ->
    {% for update in trans.updates %}
    ({{ update.variable }}' = {{ update.expression }}) &
    {% endfor %}
    (s_{{ proc.name }}' = {{ trans.to_state }});
  {% elif trans.label.startswith('call_') %}
  // Function call: {{ trans.label }} (TODO: implement logic)
  [] s_{{ proc.name }}={{ trans.from_state }}{% if trans.guard %} & {{ trans.guard.condition }}{% endif %} ->
    (s_{{ proc.name }}' = {{ trans.to_state }});
  {% elif trans.label == 'guarded' %}
  // Guarded transition
  [] s_{{ proc.name }}={{ trans.from_state }} & {{ trans.guard.condition }} ->
    (s_{{ proc.name }}' = {{ trans.to_state }});
  {% else %}
  // Internal transition
  [] s_{{ proc.name }}={{ trans.from_state }}{% if trans.guard %} & {{ trans.guard.condition }}{% endif %} ->
    (s_{{ proc.name }}' = {{ trans.to_state }});
  {% endif %}

  {% endfor %}
  // Terminal state (self-loop)
  [] s_{{ proc.name }}={{ proc.states|length }} -> (s_{{ proc.name }}' = {{ proc.states|length }});

endmodule

{%- endfor %}

// ===== Intruder/Attacker Model (Optional) =====
// TODO: Add Dolev-Yao intruder model for security analysis
// module Intruder
//   // Attacker can intercept, forge, and replay messages
// endmodule

// ===== Labels for Properties =====
// Define observable states for verification
label "error" = false;  // TODO: Define error condition
label "auth_success" = {% for proc in processes %}s_{{ proc.name }}={{ proc.states|length - 1 }}{% if not loop.last %} & {% endif %}{% endfor %};
label "deadlock" = {% for proc in processes %}s_{{ proc.name }}={{ proc.states|length }}{% if not loop.last %} | {% endif %}{% endfor %};

// ===== Rewards (Optional) =====
// rewards "message_cost"
//   [sync_ComSC_*] true : 1;  // Cost per message
// endrewards

// ===== Notes for Manual Refinement =====
// 1. Function calls (call_*) are placeholders - implement crypto logic
// 2. Add probabilistic channel model (message loss, corruption)
// 3. Implement Dolev-Yao intruder if security analysis required
// 4. Define specific error conditions in "error" label
// 5. Add reward structures for performance metrics
